# Find an optimized way to split the HGCal module sums over multiple "towers"

Towers are primitive trigger objects generated by the Trigger Primitive Generators (TPG) in the CMS level-1 trigger. They include information from the electromagnetic and hadronic calorimeters and in particular from the High Granularity Calorimeter (HGCal). When particles pass throught the HGCal detector, their energy is deposited in the HGCal modules. The energy deposited in a module (a.k.a. module sum) is split over the towers overlapping with it. My code optimizes this splitting such that the energy fraction each tower gets from a module sum is proportional to the physical area of the overlapping region.

- To run: python3 with the following packages is neeeded:
    - numpy
    - pandas
    - matplotlib
    - pyyaml
    - ROOT
    - itertools
    - math
    - root_numpy
    - scipy
    - sys
    - time
    - pathlib

(`pathlib`, `time` and probably `sys` are not very necessary and could be replaced/removed with minor changes in the code.)

## Configuration file

The config file is `config/conf_default.yaml`. In order to run or skip a function in `main.py` or `plotter.py`, only the booleans in the `mainFuncs` and/or `plotterFuncs` of the config file need to be changed, respectively. Other values in the config file are mainly for fixing I/O names and addresses.

## `main.py`

`main.py` needs to run with the config file as argument. Since the output of a function could be the input of another, I suggest to set all values in the `mainFuncs` of the config file to `True` when running for the first time. After that, each function can run independantly.

The command to run is:

`python3 main.py config/conf_default.yaml`

- The `silicons` function finds how the energy of module sums should split over the overlapping towers. The total energy is divided to (1/`N_div`)th's (e.g. 1/8th's for `N_div`=8) and split over the towers overlapping with the module. The larger the overlapping area, the more share a tower gets. The overlapping area is estimated using the number of module sensor cells enclosed by a tower. The outputs of this function are two dataframes showing the optimized split for all modules in CE-H (silicon-only) and CE-E. A few plots are also made (explained in the code). `N_div` can be changed inside the function.

- The `scintillators` function is similar to `silicons` but for scintillator modules, as name suggests. Each module covers 10 degrees in phi. Because of an existing DeltaPhi=5deg symmetry, we optimize the energy split for half of the towers and copy it for the other half. For each layer and each module u (u0 and u1), the optimization is performed. The overlapping area is calculated analytically and implemented in the `weight` function.

- `tower_per_module` function reads the parameter matrices produced in `silicons` and `scintillators`. It then finds which towers correspond to each module and writes it into a txt file.

- Likewise, `module_per_tower` function reads the parameter matrices from the output of `silicons` and `scintillators`. This function finds which modules correspond to each tower (hence, somehow the reverse of the `tower_per_module` function). The results are written into two txt files for CE-E and CE-H, seperately.


## `plotter.py`

This script is for producing some plots. It is better to run them after running all functions in `main.py` to make sure all of the ingredients for the plots are ready. The functions in this script can run independant of each other. One should set booleans of `plotterFuncs` in the config file to determine which functions to run.

The command to run is:

`python3 plotter.py config/conf_default.yaml`

## Other files/directories

The "jupyter" and "extraChecks" directories include codes for make some validation checks of the code. The input files, e.g. sensor cell or trigger cell positions are in the "input" directory and the produced mapping files are made in the "output" directory.

